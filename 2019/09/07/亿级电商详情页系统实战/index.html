<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/zhouxinjianBlog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/zhouxinjianBlog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/zhouxinjianBlog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhouxinjianBlog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/zhouxinjianBlog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/zhouxinjianBlog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/zhouxinjianBlog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="01第一讲，简单来跟大家说一下，4块 1、现在常见的java工程师/架构师对缓存技术的了解和掌握程度 我常年在一些国内最大的那些互联网公司里吧，负责招人，java这块，我们也会招，各种各样的人，我都见过 大型的互联网公司的人，传统行业的一些人，初级的人，高阶的架构师，高级工程师，技术经理，技术总监，带几十个人 缓存技术，复杂的场景的时候，很复杂的缓存架构 工作中都会用到一些缓存技术，redis/m">
<meta property="og:type" content="article">
<meta property="og:title" content="亿级电商详情页系统实战">
<meta property="og:url" content="https://zxj16152.github.io/zhouxinjianBlog/2019/09/07/亿级电商详情页系统实战/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="01第一讲，简单来跟大家说一下，4块 1、现在常见的java工程师/架构师对缓存技术的了解和掌握程度 我常年在一些国内最大的那些互联网公司里吧，负责招人，java这块，我们也会招，各种各样的人，我都见过 大型的互联网公司的人，传统行业的一些人，初级的人，高阶的架构师，高级工程师，技术经理，技术总监，带几十个人 缓存技术，复杂的场景的时候，很复杂的缓存架构 工作中都会用到一些缓存技术，redis/m">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-09-09T01:13:24.691Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="亿级电商详情页系统实战">
<meta name="twitter:description" content="01第一讲，简单来跟大家说一下，4块 1、现在常见的java工程师/架构师对缓存技术的了解和掌握程度 我常年在一些国内最大的那些互联网公司里吧，负责招人，java这块，我们也会招，各种各样的人，我都见过 大型的互联网公司的人，传统行业的一些人，初级的人，高阶的架构师，高级工程师，技术经理，技术总监，带几十个人 缓存技术，复杂的场景的时候，很复杂的缓存架构 工作中都会用到一些缓存技术，redis/m">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/zhouxinjianBlog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zxj16152.github.io/zhouxinjianBlog/2019/09/07/亿级电商详情页系统实战/">





  <title>亿级电商详情页系统实战 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/zhouxinjianBlog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/zhouxinjianBlog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/zhouxinjianBlog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zxj16152.github.io/zhouxinjianBlog/zhouxinjianBlog/2019/09/07/亿级电商详情页系统实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/zhouxinjianBlog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">亿级电商详情页系统实战</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T17:22:59+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>第一讲，简单来跟大家说一下，4块</p>
<p>1、现在常见的java工程师/架构师对缓存技术的了解和掌握程度</p>
<p>我常年在一些国内最大的那些互联网公司里吧，负责招人，java这块，我们也会招，各种各样的人，我都见过</p>
<p>大型的互联网公司的人，传统行业的一些人，初级的人，高阶的架构师，高级工程师，技术经理，技术总监，带几十个人</p>
<p>缓存技术，复杂的场景的时候，很复杂的缓存架构</p>
<p>工作中都会用到一些缓存技术，redis/memcached基础使用，初步的集群知识</p>
<p>我面试过的人里，能掌握到很少的缓存架构的人，屈指可数，个位数，而且都是在大公司有过类似的大型复杂系统架构经验的人</p>
<p>2、缓存架构/技术掌握的不够，对你的发展带来了哪些阻碍？</p>
<p>工作中</p>
<p>如果你这块技术掌握不够，然后你的公司的项目遇到了一些相关的难题，高并发+高性能的场景，hold不住类似的这种高并发的系统</p>
<p>因为缓存架构做得不好，不到位，实际在公司的项目里，出了一些大case，导致系统崩溃，巨大的经济损失</p>
<p>职业发展中</p>
<p>redis，memcached，activemq，zookeeper，kafka，lucene，activiti，爬虫，或者等等，各种技术，写了都几十种技术</p>
<p>没有一样是精通的，redis就会简单的操作，memcached操作，activemq，zookeeper，爬虫，全都是简单的操作</p>
<p>架构设计思路，有没有一些考量的点，高并发的中场景，高可用的场景，说不出来</p>
<p>不可能做到更高级的一个职位了，因为很多公司的人也不傻，技术一看就平平庸庸，怎么给你一个很好的职位呢？职业发展怎么做上去呢？</p>
<p>亮点，技术亮点，高人一筹</p>
<p>java高工，java资深工，java架构，技术亮点，造诣</p>
<p>如果你的技术很牛，各种技术都有深度，架构面临过一些复杂的场景，别人搞不定的高并发高可用的系统架构，你都能搞定，职业发展就会做的很好</p>
<p>3、课程的一个简单的介绍</p>
<p>亿级流量电商网站的商品详情页系统，项目实战，业务背景，简化，贯穿起来，学习到亿级流量的电商网站，商品详情页的整体架构设计，学到的</p>
<p>复杂的缓存架构：才是我们最真实要讲解的东西，支撑高并发，高可用</p>
<p>缓存架构过程中：我们会讲解各种高并发场景下的各种难题，怎么去解决这些难题，缓存架构的过程，各种技术和解决方案，高可用性，解决缓存架构中面临的一些高可用的问题，包括怎么去解决，技术，解决方案</p>
<p>亿级流量电商网站的商品详情页系统，架构讲解，学到，作为项目背景贯穿，项目实战；缓存架构，支撑高并发，高可用的系统架构；缓存架构观察的过程中，高并发以及高可用相关的各种技术点和知识点，解决方案，串在一起，讲解了</p>
<p>这套课程，学到很多的全网独家的技术</p>
<p>大型电商网站的商品详情页系统的架构</p>
<p>复杂的缓存架构</p>
<p>如何用复杂的缓存架构去支撑高并发</p>
<p>利用将缓存架构做成高可用机会，也可以学到高可用系统架构构建的技术</p>
<p>4、真正能支撑高并发以及高可用的复杂系统中的缓存架构有哪些东西？</p>
<p>（1）如何让redis集群支撑几十万QPS高并发+99.99%高可用+TB级海量数据+企业级数据备份与恢复？：redis企业级集群架构</p>
<p>（2）如何支撑高性能以及高并发到极致？同时给缓存架构最后的安全保护层？：(nginx+lua)+redis+ehcache的三级缓存架构</p>
<p>（3）高并发场景下，如何解决数据库与缓存双写的时候数据不一致的情况？：企业级的完美的数据库+缓存双写一致性解决方案</p>
<p>（4）如何解决大value缓存的全量更新效率低下问题？：缓存维度化拆分解决方案</p>
<p>（5）如何将缓存命中率提升到极致？：双层nginx部署架构，以及lua脚本实现的一致性hash流量分发策略</p>
<p>（6）如何解决高并发场景下，缓存重建时的分布式并发重建的冲突问题？：基于zookeeper分布式锁的缓存并发重建解决方案</p>
<p>（7）如何解决高并发场景下，缓存冷启动MySQL瞬间被打死的问题？：基于storm实时统计热数据的分布式快速缓存预热解决方案</p>
<p>（8）如何解决热点缓存导致单机器负载瞬间超高？：基于storm的实时热点发现，以及毫秒级的实时热点缓存负载均衡降级</p>
<p>（9）如何解决分布式系统中的服务高可用问题？避免多层服务依赖因为少量故障导致系统崩溃？：基于hystrix的高可用缓存服务，资源隔离+限流+降级+熔断+超时控制</p>
<p>（10）如何应用分布式系统中的高可用服务的高阶技术？：基于hystrix的容错+多级降级+手动降级+生产环境参数优化经验+可视化运维与监控</p>
<p>（11）如何解决恐怖的缓存雪崩问题？避免给公司带来巨大的经济损失？：独家的事前+事中+事后三层次完美解决方案</p>
<p>（12）如何解决高并发场景下的缓存穿透问题？避免给MySQL带来过大的压力？：缓存穿透解决方案</p>
<p>（13）如何解决高并发场景下的缓存失效问题？避免给redis集群带来过大的压力？：缓存失效解决方案</p>
<p>5、学会了这套课程，能给你带来些什么？工作中以及职业发展中？</p>
<p>工作中：如果你遇到了类似的缓存架构的一些问题，你可以立刻将学到的东西结合你的项目业务融入到架构中去；系统架构重构，抵抗各种更加复杂的场景的架构</p>
<p>职业发展中：缓存，redis，复杂的缓存架构，解决的复杂场景，技术亮点，青睐，拿到更好的职位</p>
<p>java架构师，学完这套课程行不行？绝对不行</p>
<p>java架构师必备的一项架构技能，缓存架构，高并发（缓存架构，异步队列架构，复杂的分库分表），高可用架构（hystrix分布式系统服务的高可用），微服务的架构</p>
<p>让你积累了成长为java架构师过程中，必备的一项缓存架构的技能</p>
<p>5、笔记编辑器</p>
<p>sublime</p>
<h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>我授课的一个思路，龙果另外两个课程，es的快速入门+es高手进阶</p>
<p>讲解一个技术，一个课程，就是纯讲技术，按照一个一个的技术点去讲解</p>
<p>决定拿一个从真实的系统中抽离出来的，简化过后的一个项目，去贯穿整个课程</p>
<p>项目去讲解，提供了连续而且仿真的一个业务场景</p>
<p>各种各样的业务场景，以及在业务场景中面临的难题和问题，去学习一个又一个的技术或者解决方案，或者架构设计思想</p>
<p>亿级流量电商网站的商品详情页系统</p>
<p>最最核心的架构就是缓存架构，商品详情页系统整体有自己整体的架构</p>
<p>一步一步的去实现商品详情页系统中的一些核心的部分，涉及到最最主要的就是缓存架构，高并发</p>
<p>缓存架构，一步一步讲解各种各样支撑高并发场景的缓存技术，解决方案，架构设计</p>
<p>如何将缓存架构本身做成高可用的架构，缓存架构本身面临的可用性的问题</p>
<p>基于hystrix去讲解，缓存架构本身做成高可用的，高可用架构的设计以及相关的技术</p>
<p>商品详情页系统架构 -&gt; 缓存架构 -&gt; 高并发技术+解决方案+架构 -&gt; 高可用技术+解决方案+架构</p>
<h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>商品详情页的系统架构 -&gt; 缓存架构 -&gt; 高并发 -&gt; 高可用</p>
<p>电商网站里，大概可以说分成两种，第一种小型电商，简单的一种架构方案，页面静态化的方案；大型电商，复杂的一套架构，大电商，国内排名前几的电商，用得应该咱们这里讲解的这套大型的详情页架构</p>
<p>页面静态化，全量的页面静态化</p>
<html>

<pre><code>&lt;title&gt;&lt;/title&gt;

&lt;body&gt;

    商品名称：#{productName}

    商品价格：#{productPrice}

    商品描述：#{productDesc}

&lt;/body&gt;</code></pre></html>



<p>-&gt;</p>
<html>

<pre><code>&lt;title&gt;

    &lt;style css&gt;

    &lt;javascript&gt;

&lt;/title&gt;

&lt;body&gt;

    商品名称：#{productName}

    商品价格：#{productPrice}

    商品描述：#{productDesc}

&lt;/body&gt;</code></pre></html>





<p>product1.html</p>
<p>假设是放在一个数据库里的</p>
<p>product表</p>
<p>product_name        product_price        product_desc</p>
<p>iphon7 plus            5599.50                这是最好的手机</p>
<p>-&gt;</p>
<p>iphon7 plus（玫瑰）    5299.50                这是最好的手机，大降价了</p>
<p>……1万行数据，1万个页面</p>
<p>模板的渲染</p>
<html>

<pre><code>&lt;title&gt;

    &lt;style css&gt;

    &lt;javascript&gt;

&lt;/title&gt;

&lt;body&gt;

    商品名称：iphon7 plus（玫瑰）

    商品价格：5299.50    

    商品描述：这是最好的手机，大降价了

&lt;/body&gt;</code></pre></html>



<p>iphone7_plus.html</p>
<p>如果模板改变了，那么这个模板对应的所有数据，1万个数据，全部重新渲染一遍，填充到模板中，生成最终的静态化html页面</p>
<p>对于小网站，页面很少，很实用，非常简单，模板引擎，velocity，freemarker，页面数据管理的cms系统，内容管理系统</p>
<p>点击一个按钮，做成系统自动化，重新全量渲染</p>
<p>html –&gt; 几百个页面，推送到nginx服务器上面，直接走html</p>
<p>页面太多，上亿，一个模板修改了，重新渲染一亿的商品，靠谱，几天</p>
<h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>一块儿一块儿的去讲解，商品详情页的架构实现</p>
<p>缓存架构</p>
<p>第一块儿，要掌握的很好的，就是redis架构</p>
<p>高并发，高可用，海量数据，备份，随时可以恢复，缓存架构如果要支撑这些要点，首先呢，redis就得支撑</p>
<p>redis架构，每秒钟几十万的访问量QPS，99.99%的高可用性，TB级的海量的数据，备份和恢复，缓存架构就成功了一半了</p>
<p>最最简单的模式，无非就是存取redis，存数据，取数据</p>
<p>支撑你的缓存架构，最基础的就是redis架构</p>
<p>解决各种各样高并发场景下的缓存面临的难题，缓存架构中不断的引入各种解决方案和技术，解决高并发的问题</p>
<p>解决各种各样缓存架构本身面临的高可用的问题，缓存架构中引入各种解决方案和技术，解决高可用的问题</p>
<h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>课程大纲</p>
<p>1、在虚拟机中安装CentOS</p>
<p>2、在每个CentOS中都安装Java和Perl</p>
<p>3、在4个虚拟机中安装CentOS集群</p>
<p>4、配置4台CentOS为ssh免密码互相通信</p>
<p>从零开始，纯手工，一步一步搭建出一个4个节点的CentOS集群</p>
<p>为我们后面的课程做准备，后面会讲解大型的分布式的redis集群架构，一步一步纯手工搭建redis集群，集群部署，主从架构，分布式集群架构</p>
<p>我们后面的课程，会讲解一些实时计算技术的应用，包括storm，讲解一下storm的基础知识，对于java工程师来说，会用就可以了，用一些storm最基本的分布式实时计算的feature就ok了，搭建一个storm的集群</p>
<p>部署我们整套的系统，nginx，tomcat+java web应用，mysql</p>
<p>尽量以真实的网络拓扑的环境，去给大家演示一下整套系统的部署，不要所有东西，redis集群+storm集群+nginx+tomcat+mysql，全部放在一个节点上玩儿，也可以去试一试，但是作为课程来说，效果不是太理想</p>
<p>redis集群，独立的一套机器</p>
<p>storm集群，独立的一套机器</p>
<p>nginx，独立部署</p>
<p>tomcat + java web应用，独立部署</p>
<p>mysql，独立部署</p>
<p>十几个机器，去部署整套系统，我在自己的笔记本电脑上来讲课的，这么玩儿撑不住的</p>
<p>i5，12G</p>
<p>4台虚拟机，每台虚拟机是1G的内存，电脑基本还能撑住</p>
<p>电脑本身就6个G内存的话，学习这种大型的系统架构的课程，是有点吃力，给大家建议，几个G的内存条，也就几百块钱，给自己最好加个内存条，至少到8G以上</p>
<p>16G凑合</p>
<p>纯手工，从零开始</p>
<p>很多视频课程，里面讲师都是现成的虚拟机，自己都装好了，包括各种必要的软件</p>
<p>讲课的时候直接基于自己的虚拟机就开始讲解了</p>
<p>很多同学就会发现，想要做到跟讲师一样的环境都很难，自己可能照着样子装了个环境，但是发现，各种问题，各种报错，环境起不来</p>
<p>学习课程的过程很艰难</p>
<p>学视频课程，肯定是要跟着视频的所有的东西自己去做一做，练一练，结果你却因为环境问题，做不了，连不了，那就太惨了</p>
<p>从centos的镜像文件，到所有的需要使用的软件，全都给你，在自己电脑上，下载一个虚拟机管理软件，virtual box，就可以跟着玩儿了</p>
<p>如果你一步一步跟着视频做，搭建起整个环境，应该问题不大</p>
<p>环境问题，给大家弄成傻瓜式的</p>
<hr>
<p>1、在虚拟机中安装CentOS</p>
<p>启动一个virtual box虚拟机管理软件（vmware，我早些年，发现不太稳定，主要是当时搭建一个hadoop大数据的集群，发现每次休眠以后再重启，集群就挂掉了）</p>
<p>virtual box，发现很稳定，集群从来不会随便乱挂，所以就一直用virtual box了</p>
<p>（1）使用课程提供的CentOS 6.5镜像即可，CentOS-6.5-i386-minimal.iso。</p>
<p>（2）创建虚拟机：打开Virtual Box，点击“新建”按钮，点击“下一步”，输入虚拟机名称为eshop-cache01，选择操作系统为Linux，选择版本为Red Hat，分配1024MB内存，后面的选项全部用默认，在Virtual Disk File location and size中，一定要自己选择一个目录来存放虚拟机文件，最后点击“create”按钮，开始创建虚拟机。</p>
<p>（3）设置虚拟机网卡：选择创建好的虚拟机，点击“设置”按钮，在网络一栏中，连接方式中，选择“Bridged Adapter”。</p>
<p>（4）安装虚拟机中的CentOS 6.5操作系统：选择创建好的虚拟机，点击“开始”按钮，选择安装介质（即本地的CentOS 6.5镜像文件），选择第一项开始安装-Skip-欢迎界面Next-选择默认语言-Baisc Storage Devices-Yes, discard any data-主机名:spark2upgrade01-选择时区-设置初始密码为hadoop-Replace Existing Linux System-Write changes to disk-CentOS 6.5自己开始安装。</p>
<p>（5）安装完以后，CentOS会提醒你要重启一下，就是reboot，你就reboot就可以了。</p>
<p>（6）配置网络</p>
<p>vi /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<p>DEVICE=eth0</p>
<p>TYPE=Ethernet</p>
<p>ONBOOT=yes</p>
<p>BOOTPROTO=dhcp</p>
<p>service network restart</p>
<p>ifconfig</p>
<p>BOOTPROTO=static</p>
<p>IPADDR=192.168.0.X</p>
<p>NETMASK=255.255.255.0</p>
<p>GATEWAY=192.168.0.1</p>
<p>service network restart</p>
<p>（7）配置hosts</p>
<p>vi /etc/hosts</p>
<p>配置本机的hostname到ip地址的映射</p>
<p>（8）配置SecureCRT</p>
<p>此时就可以使用SecureCRT从本机连接到虚拟机进行操作了</p>
<p>一般来说，虚拟机管理软件，virtual box，可以用来创建和管理虚拟机，但是一般不会直接在virtualbox里面去操作，因为比较麻烦，没有办法复制粘贴</p>
<p>比如后面我们要安装很多其他的一些东西，perl，java，redis，storm，复制一些命令直接去执行</p>
<p>SecureCRT，在windows宿主机中，去连接virtual box中的虚拟机</p>
<p>收费的，我这里有完美破解版，跟着课程一起给大家，破解</p>
<p>（9）关闭防火墙</p>
<p>service iptables stop</p>
<p>service ip6tables stop</p>
<p>chkconfig iptables off</p>
<p>chkconfig ip6tables off</p>
<p>vi /etc/selinux/config</p>
<p>SELINUX=disabled</p>
<p>关闭windows的防火墙</p>
<p>后面要搭建集群，有的大数据技术的集群之间，在本地你给了防火墙的话，可能会没有办法互相连接，会导致搭建失败</p>
<p>（10）配置yum</p>
<p>yum clean all</p>
<p>yum makecache</p>
<p>yum install wget</p>
<hr>
<p>2、在每个CentOS中都安装Java和Perl</p>
<p>WinSCP，就是在windows宿主机和linux虚拟机之间互相传递文件的一个工具</p>
<p>（1）安装JDK</p>
<p>1、将jdk-7u60-linux-i586.rpm通过WinSCP上传到虚拟机中</p>
<p>2、安装JDK：rpm -ivh jdk-7u65-linux-i586.rpm</p>
<p>3、配置jdk相关的环境变量</p>
<p>vi .bashrc</p>
<p>export JAVA_HOME=/usr/java/latest</p>
<p>export PATH=$PATH:$JAVA_HOME/bin</p>
<p>source .bashrc</p>
<p>4、测试jdk安装是否成功：java -version</p>
<p>（2）安装Perl</p>
<p>很多讲师，拿着自己之前花了很多时间调试好的虚拟机环境，去讲课，这个很不负责任</p>
<p>yum install -y gcc</p>
<p>wget <a href="http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz" target="_blank" rel="noopener">http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz</a></p>
<p>tar -xzf perl-5.16.1.tar.gz</p>
<p>cd perl-5.16.1</p>
<p>./Configure -des -Dprefix=/usr/local/perl</p>
<p>make &amp;&amp; make test &amp;&amp; make install</p>
<p>perl -v</p>
<p>为什么要装perl？我们整个大型电商网站的详情页系统，复杂。java+nginx+lua，需要perl。</p>
<p>perl，是一个基础的编程语言的安装，tomcat，跑java web应用</p>
<hr>
<p>3、在4个虚拟机中安装CentOS集群</p>
<p>（1）按照上述步骤，再安装三台一模一样环境的linux机器</p>
<p>（2）另外三台机器的hostname分别设置为eshop-cache02，eshop-cache03，eshop-cache04</p>
<p>（3）安装好之后，在每台机器的hosts文件里面，配置好所有的机器的ip地址到hostname的映射关系</p>
<p>比如说，在eshop-cache01的hosts里面</p>
<p>192.168.31.187 eshop-cache01</p>
<p>192.168.31.xxx eshop-cache02</p>
<p>192.168.31.xxx eshop-cache03</p>
<p>192.168.31.xxx eshop-cache04</p>
<hr>
<p>4、配置4台CentOS为ssh免密码互相通信</p>
<p>（1）首先在三台机器上配置对本机的ssh免密码登录</p>
<p>ssh-keygen -t rsa</p>
<p>生成本机的公钥，过程中不断敲回车即可，ssh-keygen命令默认会将公钥放在/root/.ssh目录下</p>
<p>cd /root/.ssh</p>
<p>cp id_rsa.pub authorized_keys</p>
<p>将公钥复制为authorized_keys文件，此时使用ssh连接本机就不需要输入密码了</p>
<p>（2）接着配置三台机器互相之间的ssh免密码登录</p>
<p>使用ssh-copy-id -i hostname命令将本机的公钥拷贝到指定机器的authorized_keys文件中</p>
<p>java，在公司里做项目，有几个人是自己去维护linux集群的啊？？？？？</p>
<p>几乎没有，很少很少，类似这一讲要做的事情，其实都是SRE，运维的同学，去做的</p>
<p>但是对于课程来说，我们只能自己一步一步做，才有环境去学习啊！！！</p>
<hr>
<p>基于虚拟机的linux集群环境，都准备好了，手上有4台机器，后面玩儿各种redis、kafka、storm、tomcat、nginx，都有机器了</p>
<h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p> 07  课程大纲</p>
<p>1、安装单机版redis</p>
<p>2、redis的生产环境启动方案</p>
<p>3、redis cli的使用</p>
<hr>
<p>1、安装单机版redis</p>
<p>大家可以自己去官网下载，当然也可以用课程提供的压缩包</p>
<p>wget <a href="http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</a></p>
<p>tar -xzvf tcl8.6.1-src.tar.gz</p>
<p>cd  /usr/local/tcl8.6.1/unix/</p>
<p>./configure  </p>
<p>make &amp;&amp; make install</p>
<p>使用redis-3.2.8.tar.gz（截止2017年4月的最新稳定版）</p>
<p>tar -zxvf redis-3.2.8.tar.gz</p>
<p>cd redis-3.2.8</p>
<p>make &amp;&amp; make test &amp;&amp; make install</p>
<hr>
<p>2、redis的生产环境启动方案</p>
<p>如果一般的学习课程，你就随便用redis-server启动一下redis，做一些实验，这样的话，没什么意义</p>
<p>要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动</p>
<p>（1）redis utils目录下，有个redis_init_script脚本</p>
<p>（2）将redis_init_script脚本拷贝到linux的/etc/init.d目录中，将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号</p>
<p>（3）修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）</p>
<p>（4）创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件）</p>
<p>（5）修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf</p>
<p>（6）修改redis.conf中的部分配置为生产环境</p>
<p>daemonize    yes                            让redis以daemon进程运行</p>
<p>pidfile        /var/run/redis_6379.pid     设置redis的pid文件位置</p>
<p>port        6379                        设置redis的监听端口号</p>
<p>dir         /var/redis/6379                设置持久化文件的存储位置</p>
<p>（7）启动redis，执行cd /etc/init.d, chmod 777 redis_6379，./redis_6379 start</p>
<p>（8）确认redis进程是否启动，ps -ef | grep redis</p>
<p>（9）让redis跟随系统启动自动启动</p>
<p>在redis_6379脚本中，最上面，加入两行注释</p>
<h1 id="chkconfig-2345-90-10"><a href="#chkconfig-2345-90-10" class="headerlink" title="chkconfig:   2345 90 10"></a>chkconfig:   2345 90 10</h1><h1 id="description-Redis-is-a-persistent-key-value-database"><a href="#description-Redis-is-a-persistent-key-value-database" class="headerlink" title="description:  Redis is a persistent key-value database"></a>description:  Redis is a persistent key-value database</h1><p>chkconfig redis_6379 on</p>
<hr>
<p>3、redis cli的使用</p>
<p>redis-cli SHUTDOWN，连接本机的6379端口停止redis进程</p>
<p>redis-cli -h 127.0.0.1 -p 6379 SHUTDOWN，制定要连接的ip和端口号</p>
<p>redis-cli PING，ping redis的端口，看是否正常</p>
<p>redis-cli，进入交互式命令行</p>
<p>SET k1 v1</p>
<p>GET k1</p>
<p>redis的技术，包括4块</p>
<p>redis各种数据结构和命令的使用，包括java api的使用</p>
<p>redis一些特殊的解决方案的使用，pub/sub消息系统，分布式锁，输入的自动完成，等等</p>
<p>redis日常的管理相关的命令</p>
<p>redis企业级的集群部署和架构</p>
<p>我们这套课程，实际上是针对企业级的大型缓存架构，用得项目，真实的大型电商网站的详情页系统（缓存）</p>
<p>我们首先讲解的第一块，其实就是企业级的大型缓存架构中的，redis集群架构（海量数据、高并发、高可用），最最流行，最最常用的分布式缓存系统</p>
<p>后面我们做商品详情页系统的业务开发的时候，当然也会去用redis的一些命令</p>
<p>redis基础知识：教程，书籍，视频</p>
<p>redis持久化、主从架构、复制原理、集群架构、数据分布式存储原理、哨兵原理、高可用架构</p>
<p>网上一些redis的教程，持久化，集群，哨兵，也讲了，都是泛泛而讲，简单带你搭建一下</p>
<p>我会深入集群架构的底层原理，哨兵的底层原理，用一线的经验，告诉你，redis的大规模的架构师如何去支撑海量数据、高并发、高可用的</p>
<h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p>课程大纲</p>
<p>1、故障发生的时候会怎么样</p>
<p>2、如何应对故障的发生</p>
<p>很多同学，自己也看过一些redis的资料和书籍，当然可能也看过一些redis视频课程</p>
<p>所有的资料，其实都会讲解redis持久化，但是有个问题，我到目前为止，没有看到有人很仔细的去讲解，redis的持久化意义</p>
<p>redis的持久化，RDB，AOF，区别，各自的特点是什么，适合什么场景</p>
<p>redis的企业级的持久化方案是什么，是用来跟哪些企业级的场景结合起来使用的？？？</p>
<p>redis持久化的意义，在于故障恢复</p>
<p>比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据</p>
<p>如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据</p>
<p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的</p>
<h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>课程大纲</p>
<p>1、RDB和AOF两种持久化机制的介绍</p>
<p>2、RDB持久化机制的优点</p>
<p>3、RDB持久化机制的缺点</p>
<p>4、AOF持久化机制的优点</p>
<p>5、AOF持久化机制的缺点</p>
<p>6、RDB和AOF到底该如何选择</p>
<p>我们已经知道对于一个企业级的redis架构来说，持久化是不可减少的</p>
<p>企业级redis集群架构：海量数据、高并发、高可用</p>
<p>持久化主要是做灾难恢复，数据恢复，也可以归类到高可用的一个环节里面去</p>
<p>比如你redis整个挂了，然后redis就不可用了，你要做的事情是让redis变得可用，尽快变得可用</p>
<p>重启redis，尽快让它对外提供服务，但是就像上一讲说，如果你没做数据备份，这个时候redis启动了，也不可用啊，数据都没了</p>
<p>很可能说，大量的请求过来，缓存全部无法命中，在redis里根本找不到数据，这个时候就死定了，缓存雪崩问题，所有请求，没有在redis命中，就会去mysql数据库这种数据源头中去找，一下子mysql承接高并发，然后就挂了</p>
<p>mysql挂掉，你都没法去找数据恢复到redis里面去，redis的数据从哪儿来？从mysql来。。。</p>
<p>具体的完整的缓存雪崩的场景，还有企业级的解决方案，到后面讲</p>
<p>如果你把redis的持久化做好，备份和恢复方案做到企业级的程度，那么即使你的redis故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务</p>
<p>redis的持久化，跟高可用，是有关系的，企业级redis架构中去讲解</p>
<p>redis持久化：RDB，AOF</p>
<hr>
<p>1、RDB和AOF两种持久化机制的介绍</p>
<p>RDB持久化机制，对redis中的数据执行周期性的持久化</p>
<p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</p>
<p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制</p>
<p>通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云，云服务</p>
<p>如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务</p>
<p>如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整</p>
<hr>
<p>2、RDB持久化机制的优点</p>
<p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据</p>
<p>（2）RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</p>
<p>（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速</p>
<hr>
<p>3、RDB持久化机制的缺点</p>
<p>（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据</p>
<p>（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</p>
<hr>
<p>4、AOF持久化机制的优点</p>
<p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据</p>
<p>（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<hr>
<p>5、AOF持久化机制的缺点</p>
<p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
<p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p>
<hr>
<p>6、RDB和AOF到底该如何选择</p>
<p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据</p>
<p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug</p>
<p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复</p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>课程大纲</p>
<p>1、如何配置RDB持久化机制</p>
<p>2、RDB持久化机制的工作流程</p>
<p>3、基于RDB持久化机制的数据恢复实验</p>
<hr>
<p>1、如何配置RDB持久化机制</p>
<p>redis.conf文件，也就是/etc/redis/6379.conf，去配置持久化</p>
<p>save 60 1000</p>
<p>每隔60s，如果有超过1000个key发生了变更，那么就生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，这个操作也被称之为snapshotting，快照</p>
<p>也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成</p>
<p>save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件</p>
<hr>
<p>2、RDB持久化机制的工作流程</p>
<p>（1）redis根据配置自己尝试去生成rdb快照文件</p>
<p>（2）fork一个子进程出来</p>
<p>（3）子进程尝试将数据dump到临时的rdb快照文件中</p>
<p>（4）完成rdb快照文件的生成之后，就替换之前的旧的快照文件</p>
<p>dump.rdb，每次生成一个新的快照，都会覆盖之前的老快照</p>
<hr>
<p>3、基于RDB持久化机制的数据恢复实验</p>
<p>（1）在redis中保存几条数据，立即停掉redis进程，然后重启redis，看看刚才插入的数据还在不在</p>
<p>数据还在，为什么？</p>
<p>带出来一个知识点，通过redis-cli SHUTDOWN这种方式去停掉redis，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照</p>
<p>/var/redis/6379/dump.rdb</p>
<p>（2）在redis中再保存几条新的数据，用kill -9粗暴杀死redis进程，模拟redis故障异常退出，导致内存数据丢失的场景</p>
<p>这次就发现，redis进程异常被杀掉，数据没有进dump文件，几条最新的数据就丢失了</p>
<p>（2）手动设置一个save检查点，save 5 1</p>
<p>（3）写入几条数据，等待5秒钟，会发现自动进行了一次dump rdb快照，在dump.rdb中发现了数据</p>
<p>（4）异常停掉redis进程，再重新启动redis，看刚才插入的数据还在</p>
<p>rdb的手动配置检查点，以及rdb快照的生成，包括数据的丢失和恢复，全都演示过了</p>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>课程大纲</p>
<p>1、AOF持久化的配置<br>2、AOF持久化的数据恢复实验<br>3、AOF rewrite<br>4、AOF破损文件的修复<br>5、AOF和RDB同时工作</p>
<hr>
<p>1、AOF持久化的配置</p>
<p>AOF持久化，默认是关闭的，默认是打开RDB持久化</p>
<p>appendonly yes，可以打开AOF持久化机制，在生产环境里面，一般来说AOF都是要打开的，除非你说随便丢个几分钟的数据也无所谓</p>
<p>打开AOF持久化机制之后，redis每次接收到一条写命令，就会写入日志文件中，当然是先写入os cache的，然后每隔一定时间再fsync一下</p>
<p>而且即使AOF和RDB都开启了，redis重启的时候，也是优先通过AOF进行数据恢复的，因为aof数据比较完整</p>
<p>可以配置AOF的fsync策略，有三种策略可以选择，一种是每次写入一条数据就执行一次fsync; 一种是每隔一秒执行一次fsync; 一种是不主动执行fsync</p>
<p>always: 每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘上去，性能非常非常差，吞吐量很低; 确保说redis里的数据一条都不丢，那就只能这样了</p>
<p>mysql -&gt; 内存策略，大量磁盘，QPS到多少，一两k。QPS，每秒钟的请求数量<br>redis -&gt; 内存，磁盘持久化，QPS到多少，单机，一般来说，上万QPS没问题</p>
<p>everysec: 每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万的</p>
<p>no: 仅仅redis负责将数据写入os cache就撒手不管了，然后后面os自己会时不时有自己的策略将数据刷入磁盘，不可控了</p>
<hr>
<p>2、AOF持久化的数据恢复实验</p>
<p>（1）先仅仅打开RDB，写入一些数据，然后kill -9杀掉redis进程，接着重启redis，发现数据没了，因为RDB快照还没生成<br>（2）打开AOF的开关，启用AOF持久化<br>（3）写入一些数据，观察AOF文件中的日志内容</p>
<p>其实你在appendonly.aof文件中，可以看到刚写的日志，它们其实就是先写入os cache的，然后1秒后才fsync到磁盘中，只有fsync到磁盘中了，才是安全的，要不然光是在os cache中，机器只要重启，就什么都没了</p>
<p>（4）kill -9杀掉redis进程，重新启动redis进程，发现数据被恢复回来了，就是从AOF文件中恢复回来的</p>
<p>redis进程启动的时候，直接就会从appendonly.aof中加载所有的日志，把内存中的数据恢复回来</p>
<hr>
<p>3、AOF rewrite</p>
<p>redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉</p>
<p>redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中</p>
<p>所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件就一个，会不断的膨胀，到很大很大</p>
<p>所以AOF会自动在后台每隔一定时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了; redis内存只剩下10万; 基于内存中当前的10万数据构建一套最新的日志，到AOF中; 覆盖之前的老日志; 确保AOF日志文件不会过大，保持跟redis内存数据量一致</p>
<p>redis 2.4之前，还需要手动，开发一些脚本，crontab，通过BGREWRITEAOF命令去执行AOF rewrite，但是redis 2.4之后，会自动进行rewrite操作</p>
<p>在redis.conf中，可以配置rewrite策略</p>
<p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</p>
<p>比如说上一次AOF rewrite之后，是128mb</p>
<p>然后就会接着128mb继续写AOF的日志，如果发现增长的比例，超过了之前的100%，256mb，就可能会去触发一次rewrite</p>
<p>但是此时还要去跟min-size，64mb去比较，256mb &gt; 64mb，才会去触发rewrite</p>
<p>（1）redis fork一个子进程<br>（2）子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志<br>（3）redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件<br>（4）子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中<br>（5）用新的日志文件替换掉旧的日志文件</p>
<hr>
<p>4、AOF破损文件的修复</p>
<p>如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损</p>
<p>用redis-check-aof –fix命令来修复破损的AOF文件</p>
<hr>
<p>5、AOF和RDB同时工作</p>
<p>（1）如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis再执行AOF rewrite，那么就不会执行RDB snapshotting<br>（2）如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite<br>（3）同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整</p>
<hr>
<p>6、最后一个小实验，让大家对redis的数据恢复有更加深刻的体会</p>
<p>（1）在有rdb的dump和aof的appendonly的同时，rdb里也有部分数据，aof里也有部分数据，这个时候其实会发现，rdb的数据不会恢复到内存中<br>（2）我们模拟让aof破损，然后fix，有一条数据会被fix删除<br>（3）再次用fix得aof文件去重启redis，发现数据只剩下一条了</p>
<p>数据恢复完全是依赖于底层的磁盘的持久化的，主要rdb和aof上都没有数据，那就没了</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>到这里为止，其实还是停留在简单学习知识的程度，学会了redis的持久化的原理和操作，但是在企业中，持久化到底是怎么去用得呢？</p>
<p>企业级的数据备份和各种灾难下的数据恢复，是怎么做得呢？</p>
<p>1、企业级的持久化的配置策略</p>
<p>在企业中，RDB的生成策略，用默认的也差不多</p>
<p>save 60 10000：如果你希望尽可能确保说，RDB最多丢1分钟的数据，那么尽量就是每隔1分钟都生成一个快照，低峰期，数据量很少，也没必要</p>
<p>10000-&gt;生成RDB，1000-&gt;RDB，这个根据你自己的应用和业务的数据量，你自己去决定</p>
<p>AOF一定要打开，fsync，everysec</p>
<p>auto-aof-rewrite-percentage 100: 就是当前AOF大小膨胀到超过上次100%，上次的两倍<br>auto-aof-rewrite-min-size 64mb: 根据你的数据量来定，16mb，32mb</p>
<p>2、企业级的数据备份方案</p>
<p>RDB非常适合做冷备，每次生成之后，就不会再有修改了</p>
<p>数据备份方案</p>
<p>（1）写crontab定时调度脚本去做数据备份<br>（2）每小时都copy一份rdb的备份，到一个目录中去，仅仅保留最近48小时的备份<br>（3）每天都保留一份当日的rdb的备份，到一个目录中去，仅仅保留最近1个月的备份<br>（4）每次copy备份的时候，都把太旧的备份给删了<br>（5）每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去</p>
<p>/usr/local/redis</p>
<p>每小时copy一次备份，删除48小时前的数据</p>
<p>crontab -e</p>
<p>0 * * * * sh /usr/local/redis/copy/redis_rdb_copy_hourly.sh</p>
<p>redis_rdb_copy_hourly.sh</p>
<p>#!/bin/sh </p>
<p>cur_date=<code>date +%Y%m%d%k</code><br>rm -rf /usr/local/redis/snapshotting/$cur_date<br>mkdir /usr/local/redis/snapshotting/$cur_date<br>cp /var/redis/6379/dump.rdb /usr/local/redis/snapshotting/$cur_date</p>
<p>del_date=<code>date -d -48hour +%Y%m%d%k</code><br>rm -rf /usr/local/redis/snapshotting/$del_date</p>
<p>每天copy一次备份</p>
<p>crontab -e</p>
<p>0 0 * * * sh /usr/local/redis/copy/redis_rdb_copy_daily.sh</p>
<p>redis_rdb_copy_daily.sh</p>
<p>#!/bin/sh </p>
<p>cur_date=<code>date +%Y%m%d</code><br>rm -rf /usr/local/redis/snapshotting/$cur_date<br>mkdir /usr/local/redis/snapshotting/$cur_date<br>cp /var/redis/6379/dump.rdb /usr/local/redis/snapshotting/$cur_date</p>
<p>del_date=<code>date -d -1month +%Y%m%d</code><br>rm -rf /usr/local/redis/snapshotting/$del_date</p>
<p>每天一次将所有数据上传一次到远程的云服务器上去</p>
<p>3、数据恢复方案</p>
<p>（1）如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据</p>
<p>不演示了，在AOF数据恢复那一块，演示了，fsync everysec，最多就丢一秒的数</p>
<p>（2）如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复</p>
<p>AOF没有破损，也是可以直接基于AOF恢复的</p>
<p>AOF append-only，顺序写入，如果AOF文件破损，那么用redis-check-aof fix</p>
<p>（3）如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复</p>
<p>当前最新的AOF和RDB文件都出现了丢失/损坏到无法恢复，一般不是机器的故障，人为</p>
<p>大数据系统，hadoop，有人不小心就把hadoop中存储的大量的数据文件对应的目录，rm -rf一下，我朋友的一个小公司，运维不太靠谱，权限也弄的不太好</p>
<p>/var/redis/6379下的文件给删除了</p>
<p>找到RDB最新的一份备份，小时级的备份可以了，小时级的肯定是最新的，copy到redis里面去，就可以恢复到某一个小时的数据</p>
<p>容灾演练</p>
<p>我跟大家解释一下，我其实上课，为什么大量的讲师可能讲课就是纯PPT，或者是各种复制粘贴，都不是现场讲解和写代码演示的</p>
<p>很容易出错，为了避免出错，一般就会那样玩儿</p>
<p>吐槽，念PPT，效果很差</p>
<p>真实的，备课，讲课不可避免，会出现一些问题，但是我觉得还好，真实</p>
<p>appendonly.aof + dump.rdb，优先用appendonly.aof去恢复数据，但是我们发现redis自动生成的appendonly.aof是没有数据的</p>
<p>然后我们自己的dump.rdb是有数据的，但是明显没用我们的数据</p>
<p>redis启动的时候，自动重新基于内存的数据，生成了一份最新的rdb快照，直接用空的数据，覆盖掉了我们有数据的，拷贝过去的那份dump.rdb</p>
<p>你停止redis之后，其实应该先删除appendonly.aof，然后将我们的dump.rdb拷贝过去，然后再重启redis</p>
<p>很简单，就是虽然你删除了appendonly.aof，但是因为打开了aof持久化，redis就一定会优先基于aof去恢复，即使文件不在，那就创建一个新的空的aof文件</p>
<p>停止redis，暂时在配置中关闭aof，然后拷贝一份rdb过来，再重启redis，数据能不能恢复过来，可以恢复过来</p>
<p>脑子一热，再关掉redis，手动修改配置文件，打开aof，再重启redis，数据又没了，空的aof文件，所有数据又没了</p>
<p>在数据安全丢失的情况下，基于rdb冷备，如何完美的恢复数据，同时还保持aof和rdb的双开</p>
<p>停止redis，关闭aof，拷贝rdb备份，重启redis，确认数据恢复，直接在命令行热修改redis配置，打开aof，这个redis就会将内存中的数据对应的日志，写入aof文件中</p>
<p>此时aof和rdb两份数据文件的数据就同步了</p>
<p>redis config set热修改配置参数，可能配置文件中的实际的参数没有被持久化的修改，再次停止redis，手动修改配置文件，打开aof的命令，再次重启redis</p>
<p>（4）如果当前机器上的所有RDB文件全部损坏，那么从远程的云服务上拉取最新的RDB快照回来恢复数据</p>
<p>（5）如果是发现有重大的数据错误，比如某个小时上线的程序一下子将数据全部污染了，数据全错了，那么可以选择某个更早的时间点，对数据进行恢复</p>
<p>举个例子，12点上线了代码，发现代码有bug，导致代码生成的所有的缓存数据，写入redis，全部错了</p>
<p>找到一份11点的rdb的冷备，然后按照上面的步骤，去恢复到11点的数据，不就可以了吗</p>
<h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>1、redis高并发跟整个系统的高并发之间的关系</p>
<p>redis，你要搞高并发的话，不可避免，要把底层的缓存搞得很好</p>
<p>mysql，高并发，做到了，那么也是通过一系列复杂的分库分表，订单系统，事务要求的，QPS到几万，比较高了</p>
<p>要做一些电商的商品详情页，真正的超高并发，QPS上十万，甚至是百万，一秒钟百万的请求量</p>
<p>光是redis是不够的，但是redis是整个大型的缓存架构中，支撑高并发的架构里面，非常重要的一个环节</p>
<p>首先，你的底层的缓存中间件，缓存系统，必须能够支撑的起我们说的那种高并发，其次，再经过良好的整体的缓存架构的设计（多级缓存架构、热点缓存），支撑真正的上十万，甚至上百万的高并发</p>
<p>2、redis不能支撑高并发的瓶颈在哪里？</p>
<p>单机</p>
<p>3、如果redis要支撑超过10万+的并发，那应该怎么做？</p>
<p>单机的redis几乎不太可能说QPS超过10万+，除非一些特殊情况，比如你的机器性能特别好，配置特别高，物理机，维护做的特别好，而且你的整体的操作不是太复杂</p>
<p>单机在几万</p>
<p>读写分离，一般来说，对缓存，一般都是用来支撑读高并发的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千</p>
<p>大量的请求都是读，一秒钟二十万次读</p>
<p>读写分离</p>
<p>主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS的架构</p>
<p>4、接下来要讲解的一个topic</p>
<p>redis replication</p>
<p>redis主从架构 -&gt; 读写分离架构 -&gt; 可支持水平扩展的读高并发架构</p>
<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>课程大纲</p>
<p>1、图解redis replication基本原理<br>2、redis replication的核心机制<br>3、master持久化对于主从架构的安全保障的意义</p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p>redis replication的最最基本的原理，铺垫</p>
<hr>
<p>1、图解redis replication基本原理</p>
<hr>
<p>2、redis replication的核心机制</p>
<p>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量<br>（2）一个master node是可以配置多个slave node的<br>（3）slave node也可以连接其他的slave node<br>（4）slave node做复制的时候，是不会block master node的正常工作的<br>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了<br>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</p>
<p>slave，高可用性，有很大的关系</p>
<hr>
<p>3、master持久化对于主从架构的安全保障的意义</p>
<p>如果采用了主从架构，那么建议必须开启master node的持久化！</p>
<p>不建议用slave node作为master node的数据热备，因为那样的话，如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了</p>
<p>master -&gt; RDB和AOF都关闭了 -&gt; 全部在内存中</p>
<p>master宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己IDE数据是空的</p>
<p>master就会将空的数据集同步到slave上去，所有slave的数据全部清空</p>
<p>100%的数据丢失</p>
<p>master节点，必须要使用持久化机制</p>
<p>第二个，master的各种备份方案，要不要做，万一说本地的所有文件丢失了; 从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的</p>
<p>即使采用了后续讲解的高可用机制，slave node可以自动接管master node，但是也可能sentinal还没有检测到master failure，master node就自动重启了，还是可能导致上面的所有slave node数据清空故障</p>
<h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>课程大纲</p>
<p>1、主从架构的核心原理</p>
<p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</p>
<p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization</p>
<p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
<p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
<p>2、主从复制的断点续传</p>
<p>从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p>
<p>master node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p>
<p>但是如果没有找到对应的offset，那么就会执行一次resynchronization</p>
<p>3、无磁盘化复制</p>
<p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p>
<p>repl-diskless-sync<br>repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p>
<p>4、过期key处理</p>
<p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/zhouxinjianBlog/2019/09/06/堆内存的分配/" rel="next" title="堆内存的分配">
                <i class="fa fa-chevron-left"></i> 堆内存的分配
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/zhouxinjianBlog/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#01"><span class="nav-number">1.</span> <span class="nav-text">01</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02"><span class="nav-number">2.</span> <span class="nav-text">02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03"><span class="nav-number">3.</span> <span class="nav-text">03</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05"><span class="nav-number">4.</span> <span class="nav-text">05</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06"><span class="nav-number">5.</span> <span class="nav-text">06</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07"><span class="nav-number">6.</span> <span class="nav-text">07</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#chkconfig-2345-90-10"><span class="nav-number"></span> <span class="nav-text">chkconfig:   2345 90 10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#description-Redis-is-a-persistent-key-value-database"><span class="nav-number"></span> <span class="nav-text">description:  Redis is a persistent key-value database</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#08"><span class="nav-number">1.</span> <span class="nav-text">08</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#09"><span class="nav-number">2.</span> <span class="nav-text">09</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11"><span class="nav-number">3.</span> <span class="nav-text">11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12"><span class="nav-number">4.</span> <span class="nav-text">12</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3"><span class="nav-number">5.</span> <span class="nav-text">3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14"><span class="nav-number">6.</span> <span class="nav-text">14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15"><span class="nav-number">7.</span> <span class="nav-text">15</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16"><span class="nav-number">8.</span> <span class="nav-text">16</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/zhouxinjianBlog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/zhouxinjianBlog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/zhouxinjianBlog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/zhouxinjianBlog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/zhouxinjianBlog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/zhouxinjianBlog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
